"""Generate a worktree-add.sh script for a bare git repository."""

import argparse
import platform
import stat
import subprocess
import sys
from pathlib import Path

from .common import PLANNER_DIR, load_json, resolve_repo_path


def find_git_dir(repo_path: Path) -> Path | None:
    """Locate the git directory for a bare repository.

    Returns the git dir path, or None if this isn't a bare repo.
    Supports .bare directory convention and standard bare repos.
    """
    bare_dir = repo_path / ".bare"
    if bare_dir.is_dir():
        return bare_dir

    result = subprocess.run(
        ["git", "-C", str(repo_path), "rev-parse", "--is-bare-repository"],
        capture_output=True, text=True,
    )
    if result.returncode == 0 and result.stdout.strip() == "true":
        return repo_path

    return None


def generate_script(planning_root: Path, planner_dir: Path) -> str:
    """Generate the contents of a worktree-add.sh script.

    Paths are baked in at generation time. The generated script is
    self-contained and requires only bash + git to run.
    """
    return f'''\
#!/usr/bin/env bash
set -euo pipefail

# ============================================================================
# worktree-add — Create or repair a worktree with Claude planner integration
#
# Generated by setup-worktree.py — regenerate with:
#   python3 {planner_dir}/setup-worktree.py "$(pwd)"
#
# Usage:
#   ./worktree-add.sh <branch> [path]
#
# Examples:
#   ./worktree-add.sh main
#   ./worktree-add.sh feature/new-thing
#   ./worktree-add.sh feature/nfs feature/nfs   # re-run on existing worktree
# ============================================================================

REPO_ROOT="$(cd "$(dirname "$0")" && pwd)"
PLANNER_DIR="{planner_dir}"
PLANNING_ROOT="{planning_root}"

# Locate the git directory (.bare or the repo itself)
if [[ -d "$REPO_ROOT/.bare" ]]; then
    GIT_DIR="$REPO_ROOT/.bare"
else
    GIT_DIR="$REPO_ROOT"
fi

# --------------------------------------------------------------------------
usage() {{
    echo "Usage: $0 <branch> [path]"
    echo ""
    echo "  branch   Git branch name (e.g., main, feature/nfs)"
    echo "  path     Worktree path relative to repo root (defaults to branch name)"
    echo ""
    echo "Creates a new worktree or repairs an existing one."
    exit 1
}}

if [[ $# -lt 1 ]]; then
    usage
fi

BRANCH="$1"
WT_REL="${{2:-$BRANCH}}"
WT_PATH="$REPO_ROOT/$WT_REL"

# --------------------------------------------------------------------------
# Step 1: Create worktree if it doesn't exist
# --------------------------------------------------------------------------
if [[ -d "$WT_PATH" && -e "$WT_PATH/.git" ]]; then
    echo "Worktree already exists at $WT_REL — repairing setup..."
else
    echo "Creating worktree: $WT_REL (branch: $BRANCH)"

    if git --git-dir="$GIT_DIR" show-ref --verify --quiet "refs/remotes/origin/$BRANCH" 2>/dev/null; then
        if git --git-dir="$GIT_DIR" show-ref --verify --quiet "refs/heads/$BRANCH" 2>/dev/null; then
            mkdir -p "$(dirname "$WT_PATH")"
            git --git-dir="$GIT_DIR" worktree add "$WT_PATH" "$BRANCH"
        else
            mkdir -p "$(dirname "$WT_PATH")"
            git --git-dir="$GIT_DIR" worktree add --track -b "$BRANCH" "$WT_PATH" "origin/$BRANCH"
        fi
    elif git --git-dir="$GIT_DIR" show-ref --verify --quiet "refs/heads/$BRANCH" 2>/dev/null; then
        mkdir -p "$(dirname "$WT_PATH")"
        git --git-dir="$GIT_DIR" worktree add "$WT_PATH" "$BRANCH"
    else
        echo "Branch '$BRANCH' does not exist. Creating new branch."
        mkdir -p "$(dirname "$WT_PATH")"
        git --git-dir="$GIT_DIR" worktree add -b "$BRANCH" "$WT_PATH" HEAD
    fi

    # Initialize submodules if present
    if [[ -f "$WT_PATH/.gitmodules" ]]; then
        echo "Initializing submodules..."
        (cd "$WT_PATH" && git submodule update --init --recursive)
    fi
fi

# --------------------------------------------------------------------------
# Step 2: Ensure remote tracking is set up
# --------------------------------------------------------------------------
if git --git-dir="$GIT_DIR" show-ref --verify --quiet "refs/remotes/origin/$BRANCH" 2>/dev/null; then
    CURRENT_REMOTE="$(git --git-dir="$GIT_DIR" config --get "branch.$BRANCH.remote" 2>/dev/null || true)"
    if [[ -z "$CURRENT_REMOTE" ]]; then
        echo "Setting up remote tracking: $BRANCH → origin/$BRANCH"
        git --git-dir="$GIT_DIR" config "branch.$BRANCH.remote" "origin"
        git --git-dir="$GIT_DIR" config "branch.$BRANCH.merge" "refs/heads/$BRANCH"
    fi
fi

# --------------------------------------------------------------------------
# Step 3: Set up planning-config.json
# --------------------------------------------------------------------------
CONFIG_FILE="$WT_PATH/planning-config.json"
EXPECTED_ROOT="$PLANNING_ROOT"

if [[ -f "$CONFIG_FILE" ]]; then
    CURRENT_ROOT="$(python3 -c "import json; print(json.load(open('$CONFIG_FILE')).get('planningRoot',''))" 2>/dev/null || true)"
    if [[ "$CURRENT_ROOT" != "$EXPECTED_ROOT" ]]; then
        echo "Fixing planning-config.json (was: $CURRENT_ROOT)"
        python3 -c "import json; json.dump({{\\"mode\\": \\"standalone\\", \\"planningRoot\\": \\"$EXPECTED_ROOT\\"}}, open('$CONFIG_FILE','w'), indent=2); open('$CONFIG_FILE','a').write('\\\\n')"
    else
        echo "planning-config.json: OK"
    fi
else
    echo "Creating planning-config.json"
    python3 -c "import json; json.dump({{\\"mode\\": \\"standalone\\", \\"planningRoot\\": \\"$EXPECTED_ROOT\\"}}, open('$CONFIG_FILE','w'), indent=2); open('$CONFIG_FILE','a').write('\\\\n')"
fi

# --------------------------------------------------------------------------
# Step 4: Clean stale planner symlinks
# --------------------------------------------------------------------------
CLEANED=0
for dir in "$WT_PATH/.claude/skills" "$WT_PATH/.claude/agents"; do
    if [[ -d "$dir" ]]; then
        for link in "$dir"/*.md; do
            [[ -e "$link" ]] || continue
            if [[ -L "$link" ]]; then
                TARGET="$(readlink "$link")"
                if [[ "$TARGET" == "$PLANNER_DIR/"* ]]; then
                    rm "$link"
                    CLEANED=$((CLEANED + 1))
                fi
            fi
        done
    fi
done

if [[ $CLEANED -gt 0 ]]; then
    echo "Cleaned $CLEANED stale planner symlinks (now using --add-dir)"
fi

# --------------------------------------------------------------------------
# Step 5: Write claude.sh
# --------------------------------------------------------------------------
CLAUDE_SH="$WT_PATH/claude.sh"
cat > "$CLAUDE_SH" << 'LAUNCHER'
#!/usr/bin/env bash
# Launch Claude Code with planning context and planner plugin
exec claude \\
    --add-dir="{planning_root}" \\
    --plugin-dir="{planner_dir}" \\
    "$@"
LAUNCHER
chmod +x "$CLAUDE_SH"
echo "claude.sh: written"

# --------------------------------------------------------------------------
# Summary
# --------------------------------------------------------------------------
echo ""
echo "=== Worktree ready: $WT_REL ==="
echo "  Path:     $WT_PATH"
echo "  Branch:   $BRANCH"
echo "  Planning: $PLANNING_ROOT"
echo ""
echo "  cd $WT_PATH && ./claude.sh"
'''


def main(argv: list[str] | None = None) -> None:
    parser = argparse.ArgumentParser(
        description="Generate a worktree-add.sh script for a bare git repository.",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog=(
            "examples:\n"
            "  %(prog)s /path/to/bare-repo\n"
            "  %(prog)s /path/to/bare-repo --planning-root /path/to/planning\n"
            "  %(prog)s my-repo   # repo key from planning-config.local.json\n"
        ),
    )
    parser.add_argument(
        "repo",
        help="path to bare git repository, or a key from planning-config.local.json",
    )
    parser.add_argument(
        "--planning-root",
        type=Path,
        default=None,
        help="path to planning artifacts (defaults to project-planner directory)",
    )

    args = parser.parse_args(argv)

    repo_path = resolve_repo_path(args.repo)
    planning_root = (args.planning_root or PLANNER_DIR).resolve()

    # Verify this is a bare repo
    git_dir = find_git_dir(repo_path)
    if git_dir is None:
        print(f"Error: {repo_path} does not appear to be a bare git repository", file=sys.stderr)
        print("  Expected .bare/ directory or a bare repository.", file=sys.stderr)
        sys.exit(1)

    # Generate and write the script (overwrites any existing)
    script_content = generate_script(planning_root, PLANNER_DIR)
    script_path = repo_path / "worktree-add.sh"
    existed = script_path.exists()
    script_path.write_text(script_content)

    if platform.system() != "Windows":
        mode = script_path.stat().st_mode
        script_path.chmod(mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)

    verb = "Overwritten" if existed else "Generated"
    print(f"{verb}: {script_path}")
    print(f"  Planning root: {planning_root}")
    print(f"  Plugin dir:    {PLANNER_DIR}")
    print()
    print(f"Usage: cd {repo_path} && ./worktree-add.sh <branch>")
